# Категории выражений

Помимо типов, все выражения в C++ характеризуются принадлежностью к одной из категорий. Исторически определение категории выражения пошло из языка C. Изначально все выражения делились на две категории: ```lvalue``` и ```rvalue```, где буквы l (left) и r (right) обозначали положение выражения относительно знака присваивания.

Причину такого деления можно объяснить на простейшем примере:

```cpp
extern int x;
extern int y;
x = y;
```

Казалось бы, что может быть проще. И слева, и справа стоят выражения состоящие из одной переменной. Но, несмотря на схожесть выражений, результаты вычислений этих выражений различны. Результатом ```rvalue``` выражения является значение, которое хранится в ячейке памяти ```y```. А ```lvalue``` выражение вычисляет цель (адрес в памяти), куда помещается вычисленное значение. То есть ```lvalue``` выражение, говорят, обладает свойством идентичности, то есть имеет параметр, по которому можно понять ссылаются ли два выражения на один объект или нет. ```rvalue``` выражения таким свойством не обладают, но они обладают возможностью перемещения, то есть могут быть переданы на вход другого выражения.

Свойства идентичности и перемещаемости можно пронаблюдать, обратившись к коду, порожденному компилятором. За основу возьмем следующий фрагмент кода:

```cpp
a[n] = b + c * d;
```

В приведенном примере как левое, так и правое выражения не являются тривиальными и мы можем описать порядок их вычисления. В левой части требуется вычислить адрес ```n```-го элемента массива ```a```. Для этого к адресу, хранящемуся в ```a```, необходимо прибавить смещение, которое равно произведению ```n``` на размер объекта типа ```a```. Как и ожидалось, ```lvalue``` выражение обладает идентичностью, то есть адресом в памяти, который мы и вычислили. Справа же мы сначала должны перемножить значения ```c``` и ```d```, а затем результат сложить со значением ```b```. Очевидно, что как все выражение целиком, так и его часть являются ```rvalue``` выражениями, то есть они не обладают идентичностью. Для конкретной платформы это обычно означает, что результат, например, произведения не сохраняется в памяти, а лишь хранится в регистре, откуда в дальнейшем будет перемещен по адресу назначения.

В C++ система категорий значений получила дальнейшее развитие. Было введено понятие ```xvalue``` (“eXpiring” value) выражения - выражения, которое обладает идентичностью, но ресурсы которого могут быть переиспользованы, то есть оно также обладает и свойством перемещаемости. Вместе с ```lvalue```, новый тип выражения объединяются в общую категорию ```glvalue``` (“generalized” ```lvalue```). С другой стороны ```xvalue``` также являются и ```rvalue```, поэтому чтобы отличать их от остальных ```rvalue``` (которые не обладают идентичностью) выделили еще одну подкатегорию ```prvalue``` (“pure” ```rvalue```).

Стандартом довольно подробно описано, к какой категории относятся различные типы выражений и какими свойствами они обладают. Но все же, до принятия стандарта C++11, эти категории были важны больше для разработчиков компиляторов, нежели чем для программистов, пишущих на C++. Единственное, что могло дать знание категорий выражений, - это возможность поразить своих коллег каким-нибудь замысловатым кодом типа приведенного ниже.

```cpp
extern int n;
(n >= 10 ? throw std::invalid_argument("Value is too big") : n) = n + 1;
```

По правилам, описанным в стандарте, этот тернарный оператор является ```lvalue``` выражением и, соответственно, приведенный код корректен.

Однако, с принятием стандарта C++11, появилась новая сущность: ```rvalue``` ссылка, которая значительно расширила возможности для манипулирования с выражениями различных категорий.

## lvalue и rvalue ссылки

Для начала рассмотрим механизм ссылок в общем. В C++, как в языке совместимым с C, унаследован механизм указателей и на первый взгляд может показаться, что эти два механизма очень схожи. Однако указатель - это все же переменная, которая хранит адрес объекта заданного типа. Ссылка же является просто псевдонимом какого-то конкретного объекта. Из этого вытекает, что ссылка не может указывать ни на что, то есть она должна быть проинициализирована в месте объявления и в течение всей жизни она не может быть переназначена на другой объект.

Еще одной важной особенностью ссылок является то, что их можно инициализировать ```rvalue``` выражением (точнее можно инициализировать ```rvalue``` или константную ```lvalue``` ссылку). Время жизни объекта при этом продлевается до конца жизни ссылки. Таким образом следующий код вполне корректен.

```cpp
extern int a;
int foo();
void bar(int);
const int& ref = a + foo();
/* some code */
bar(ref);
```

Второе важное свойство ссылок - это правило применения перегруженной функции. Если существуют две перегруженные функции, одна из которых принимает ```rvalue``` ссылку, а вторая - ```lvalue``` ссылку, то для аргумента, являющегося ```rvalue``` выражением, будет вызвана первая версия.

Приведенные выше свойства позволяют реализовать в языке мощный механизм, получивший название семантика перемещения.

## Семантика перемещения

Любая программа работает с данными. Данные извлекаются, обрабатываются и отправляются куда-то дальше. В такой ситуации не избежать копирования. Но во всех ли случаях это копирование неизбежно? Рассмотрим простой пример конкатенации строк. Самый очевидный и наглядный способ это сделать выглядит следующим образом.

```cpp
extern std::string result;
result = firstString + secondString;
```

Главное преимущество такого способа - его читабельность. Даже не видя всего контекста для всех очевидно, что тут происходит. Но с точки зрения производительности этот код очень неэффективен. Здесь создается временный объект в который копируется содержимое первой строки, а затем в конец копируется содержимое второй. Хорошо, если размер буфера окажется достаточно большим, чтобы вместить результат. Иначе нас ждет перевыделение памяти и еще одно копирование. Но и на этом еще не конец, необходимо еще одно копирование в целевую переменную.

Конечно компиляторы способны распознать популярные паттерны, и, возможно, они хотя бы частично справятся с таким кодом. Но его возможности ограничены и в более запутанном случае он окажется бессильным. И тогда приходится решать проблему производительности вручную. В результате появляются варианты наподобие такого.

```cpp
extern std::string result;
result.reserve(firstString.length() + secondString.length() + 1);
result = firstString;
result.append(secondString);
```

Второй вариант делает то же самое и возможно делает это эффективнее. Но теперь, чтобы понять, что тут происходит, одного взгляда уже недостаточно. Даже на таком наивном примере очевидно, что попытки избавиться от лишнего копирования приводят к очень запутанному коду.

Однако с появлением возможности перемещения в C++11, часть проблем решились сами собой. Просто код из первого примера будет работать гораздо эффективнее. Дело в том, что конкатенация двух строк есть rvalue выражение, результат которого после копирование будет уничтожен. Так почему бы вместо копирования внутреннего буфера строки не использовать перемещение? То есть будет копироваться не буфер, а только указатель на него, что гораздо менее затратно. Но только скопировать указатель не достаточно, так как после копирования будет вызван деструктор для строки источника, буфер будет освобожден и мы получим повисший указатель. Поэтому вторая важная часть процедуры перемещения - это модификация источника таким образом, чтобы он больше не владел перемещенными ресурсами, но оставался в корректном состоянии, которое не приведет к неопределенному поведению при вызове деструктора.

Важно понимать, что сама по себе семантика перемещения не дает какого-то прироста производительности. Это лишь инструмент, позволяющий этого добиться в определенных ситуациях. Так в примере со строками это достигается благодаря тому, что в стандартной библиотеке для этого класса реализованы конструктор и оператор перемещения, которые и позволили коду стать более эффективным. Для простых POD (Plain Old Data) структур семантика перемещения не дает никаких преимуществ, так как базовые типы могут быть только скопированы.

Говоря о семантике перемещения стоит упомянуть и о новых возможностях для ресурсов, которые не могут быть скопированы. Речь идет о ресурсах операционной системы: потоках выполнения, файловых дескрипторах, сетевых соединениях и т. п. Однако теперь они могут быть переданы от одного владельца к другому. Данный механизм позволяет гарантировать, что владелец всегда будет только один. Раньше проблему передачи можно было решить в два шага: разделение владения ресурсом через механизм копирования указателя на объект обертку и прекращение владения ресурсом передающей стороной через обнуления указателя на обертку. Но не атомарность механизма обычно приводит к ошибкам согласования процесса. Кроме того промежуточное состояние, как правило, неустойчивое и любая нештатная ситуация на этом этапе может привести к нежелательным последствиям.

Разделение механизмов перемещения и копирования дает более гибкие возможности. Например, можно явно запретить копирование, разрешив только перемещение. Таким образом мы можем эмулировать механизм единоличного владения объектом. Этот принцип лежит в реализации ```std::unique_ptr``` в стандартной библиотеке C++.
