# Категории программ в стандарте C++

С точки зрения стандарта C++ любая программа попадает в одну из следующих категорий:
* conforming code;
* ill-formed;
* ill-formed no diagnostic required;
* implementation defined behavior;
* unspecified behavior;
* undefined behavior.

В первую категорию попадают программы, которые полностью соответствуют стандарту. И их поведение точно описывается им.

Во вторую категорию попадают программы с синтаксическими или с диагностируемыми семантическими ошибками. По сути, данный текст не является программой.

К третьей категории относятся программы с семантическими ошибками, которые невозможно выявить на этапе компиляции. Некоторые ошибки, однако, могут быть выявлены на этапе линковки. Результат исполнения такой программы не определен.

Поведение программы из четверной категории зависит от платформы, компилятора или даже версии компилятора, но для конкретной реализации оно определено и задокументировано. К данной категории относятся, например, содержимое в сообщении об ошибки при попытке выделить память, число битов в байте и т. д.

Поведение программ из пятой категории также зависит от реализации компилятора. Но, в отличии от предыдущей категории, это поведение не требует документирования. Примерами такого поведения являются порядок вычисления аргументов функции, способы хранения одинаковых строковых литералов. Исполнение такой программы приводит к одному из набора допустимых результатов.

Последняя категория представляет наибольший интерес. Поведение программ, попадающих в эту категорию, никаким образом не регламентируется стандартом и не ограничивается им. То есть любой результат, даже самый плачевный, не будет являться нарушением стандарта. Примерами неопределенного поведения являются обращение за границы массива, обращение к неинициализированной переменной, несколько изменений одного и того же скаляра в одном выражении с неопределенным 
порядком вычисления.

## Неопределенное поведение

Неопределенное поведение - одна и наиболее сложных проблем в C++. Необходимо четко понимать, что в отличии от поведения, зависящего от реализации, (как документированного, так и не документированного), мы не вправе делать какие-либо предположения о неопределенном поведении.

Возникает вопрос, неужели неопределенное поведение такое неизбежное зло и нет способа избавиться от него?
К сожалению, это так. И этому есть как минимум два объяснения:
1. C++ — это высокоуровневый язык программирования, и стандарт стремится минимизировать объем предположений о целевой платформе, для которой реализуется компилятор. Поэтому, например, в стандарте не делается предположений о способе представления целых чисел со знаком и о поведении при их переполнении. Вариант с дополнительным кодом хоть и очень популярен, но он не единственный. В цифровых сигнальных процессорах, например, активно используется представление чисел в непозиционная системе счисления, такая как система остаточных классов.
1. Одним из основополагающих принципов C++ является принцип “не платить за то, что не используется”. Руководствуясь этим принципом, стандарт не требует осуществлять проверку границ массива. К тому же не понятно, что делать, если бы этот факт был детектирован. Механизм обработки таких событий потребовал дополнительных предположений о платформе, что в свою очередь снижает возможности портирования компилятора.

Таким образом авторы стандарта значительно расширили возможности для применения оптимизаций на этапе компиляции, так как алгоритму не требуется обрабатывать те редкие специальные случаи, которые помечены в стандарте, как неопределенное поведение.

Стоит отметить, что такое допущение иногда порождает довольно забавные ситуации. И на просторах Интернета можно найти большое количество примеров, где неопределенное поведение приводит к довольно курьезным результатам. Например, приведенный ниже код может быть оптимизирован компилятором в функцию, всегда возвращающую true. И действительно, либо в массиве есть элемент равный аргументу функцию, либо тут имеет место неопределенное поведение.

```cpp
int array[4];
int value = 10;

bool check(int v)
{
    for(int i = 0; i <= 4; ++i)
        if(array[i] == v)
            return true;
    return false;
}
```
