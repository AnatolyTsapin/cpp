# Типы

C++ является статически типизированным языком, то есть все переменные, параметры и возвращаемые значения связываются с типом в момент объявления и не могут быть изменены позже. Тип определяет свойства объекта, связанного с ним. Он говорит, каким образом интерпретировать данные, накладывает ограничения на работу с этими данными.

Статическая типизация дает следующие преимущества:
* большая часть ошибок выявляется на этапе компиляции;
* порождаемый код как правило более компактный и имеет высокую производительность.

Главным же недостатком статической типизации является относительно большая многословность программ.

Практика показывает, что языки со статической типизацией наиболее хороши для больших и сложных проектов.

В C++ все типы делятся на две группы:
* базовые типы: ```void```, ```nullptr_t``` и все арифметические типы, включая целые числа, числа с плавающей точкой и булевый тип;
* составные типы: указатели, ссылки, функции, массивы, перечисления и классы.

Другими словами можно сказать, что базовые типы являются встроенными, то есть они есть часть языка. Составные типы же описываются пользователем.

## Манипуляции с типами

Любая программа работает с данными. Входные данные обрабатываются, преобразуются и выдаются на выход в виде результата. В контексте языков со статической типизацией это означает, что данные одного типа преобразуются в данные другого типа. То есть приведение типов является базовой функциональностью языка.

Очевидно, что для встроенных типов правила приведения определены стандартом. Прежде всего необходимо различать расширение (promotion) чисел и приведение. Расширяться могут целые числа размера меньше int в int. Для чисел с плавающей точкой допустимо расширение ```float``` в ```double```. Булевая переменная также может расширится в ```int```, при этом значение ```false``` будет преобразовано в ```0```, а ```true``` - в ```1```.

В отличии от расширения, приведение допустимо из любого в любой встроенные типы. При этом приведение к более узкому типу четко определено только для беззнаковых целых: в результат записывается число по модулю размера целевого типа. Для знаковых целых такое преобразование возможно только при условии, что значение находится в диапазоне возможных значений целевого типа, в противном случае будет неопределенное поведение.

Преобразование между различными типами чисел с плавающей точкой и между целыми числами и числами с плавающей точкой также возможно. Если в результате преобразования теряется точность числа, то способ округления определяется реализацией.

Любой численный тип может быть приведен к булевому типу. При этом нулевое значение будет приведено к значению ```false```, а любое отличное от нуля - к значению ```true```.

Для пользовательских типов, по понятным причинам, никаких стандартных преобразований не определено. Существует два способа описания пользовательских преобразований:
* оператор приведения к типу T позволяет определить, каким образом данный тип приводится к какому-то другому;
* конструктор с одним параметром T - определяет, как какой-то произвольный тип привести к данному.

Описанные механизмы являются основой, с помощью которой можно осуществлять преобразование типов в C++. При этом эти преобразования могут выполняться, как явно с помощью специальных ключевых слов, так и неявно.

### Неявное приведение типов

Неявное приведение типов позволяет улучшить читаемость кода за счет опускания очевидных деталей. Любое неявное преобразование всегда может быть выражено эквивалентным явным, это не будет ошибкой.

Неявное преобразование осуществляется, когда выражение некоторого типа ```Т1``` применяется в контексте, который не принимает данный тип, но принимает другой тип ```Т2```, в ситуациях:
* когда выражение является аргументом вызываемой функции, тип аргумента которой объявлен как ```Т2```;
* когда выражение является операндом оператора, принимающего тип ```Т2```;
* когда инициализируется новый объект типа ```Т2```, включая конструкцию ```return``` функции с возвращаемым значением типа ```Т2```;
* когда выражение используется в конструкции ```switch``` (тип ```T2``` является целочисленным типом);
* когда выражение используется в конструкции ```if``` или ```while``` (тип ```T2``` является булевым).

Программа является корректной, если существует одна недвусмысленная последовательность неявных преобразований из типа ```T1``` в тип ```T2```.

Последовательность преобразований состоит из следующих шагов:
1. ноль или одно стандартное преобразование;
1. ноль или одно пользовательское преобразование;
1. ноль или одно стандартное преобразование.

При приведении одного встроенного типа в другой допускается только одно стандартное преобразование. При этом расширение типа имеет более высокий приоритет по сравнению с приведением.

Поэтому приведенная ниже программа выдает именно такой результат

```cpp
#include <iostream>

void foo(int i)
{
    std::cout << "int" << std::endl;
}

void foo(unsigned int i)
{
    std::cout << "unsigned int" << std::endl;
}

int main()
{
    unsigned char c = 42;
    foo(c);
    return 0;
}
```

### Явное приведение типов
В C++ определены 4 ключевых слова, которые позволяют осуществлять явное приведение типов:
* ```static_cast```;
* ```dynamic_cast```;
* ```const_cast```;
* ```reinterpret_cast```.

#### static_cast

Полный список возможностей применения ```static_cast``` имеет порядка десяти пунктов. Но, если не углубляться в детали, можно выделить несколько основных сценариев использования.

Этот вид приведения должен всегда использоваться в качестве замены неявному приведению. Также ```static_cast``` первый претендент для всевозможных преобразований между встроенными типами. Если в приведенном выше примере нас не устраивает результат неявного приведения, можно переписать код следующим образом:

```cpp
#include <iostream>

void foo(int i)
{
    std::cout << "int" << std::endl;
}

void foo(unsigned int i)
{
    std::cout << "unsigned int" << std::endl;
}

int main()
{
    unsigned char c = 42;
    foo(static_cast<unsigned int>(c));
    return 0;
}
```

Из самого названия ключевого слова следует, что преобразование осуществляется статически, то есть вся информация о типах и способах приведения одного к другому должна быть известна на этапе компиляции.

#### dynamic_cast

Этот вид преобразования предназначен для работы с динамическими типами. Динамическими типами являются указатели и ссылки на полиморфные объекты. То есть указатель класса родительского типа может указывать на объект любого своего потомка и определить, на какой именно на этапе компиляции, не представляется возможным.

Приведение ```dynamic_cast``` применяется для приведения указателя или ссылки как вверх, так и вниз по иерархии наследования классов. Для корректного приведения необходима информация времени исполнения, то есть это преобразование имеет накладные расходы на проверку и не всегда завершается успехом.

В случае невозможности приведения указателя ```dynamic_cast``` вернет ```nullptr```, а при неудачном приведении ссылки - бросит исключение ```std::bad_cast```.

#### const_cast

Приведение ```const_cast``` позволяет изменять cv-квалификатор типа, то есть оно позволяет отменять константность и/или волатильность объекта. Этот тип приведения имеет довольно узкий круг применения. Как правило отменять константность требуется для согласования со сторонними библиотеками, где функции принимают не константные объекты, хотя де-факто они их не модифицируют. Применение ```const_cast``` позволяет избежать ненужного копирования.

Еще один из случаев применения ```const_cast``` можно назвать трюк, позволяющий избежать дублирования кода при реализации константного и не константного геттеров.

#### reinterpret_cast

```reinterpret_cast``` один из самых сильных и самых опасных манипуляторов типами. В отличии от всех остальных привидений, данное привидение не порождает какого-либо кода. Эта инструкция просто говорит компилятору интерпретировать участок памяти, аллоцированный для типа T1, как тип T2. Единственное ограничение, что эти типы должны быть одинакового размера. Поэтому reinterpret_cast как правило применяется к указателям и используется в низкоуровневом программировании.

#### C-style приведение

C++ совместим с C, поэтому возможно (хотя и нежелательно) применение C-style приведения типов. В данном случае компилятор последовательно пытается заменить приведение в следующей последовательности:
* ```const_cast```
* ```static_cast```
* ```static_cast``` с последующим ```const_cast```
* ```reinterpret_cast```
* ```reinterpret_cast``` с последующим ```const_cast```

Поиск прекращается, как только находится первая подходящая подстановка, даже если это приводит к ошибке компиляции.
