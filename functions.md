# Функции и методы

С точки зрения стандарта функция в C++ это сущность, которая связывает последовательность операторов (тело функции) с именем и списком параметров. Список параметров может быть пустым.

При вызове функции, ее параметры инициализируются аргументами и затем выполняется тело функции. Исполнение функции может быть прервано оператором возврата или вследствие возникновения исключения.

Функции имеют тип, который определяется типом возвращаемого значения и типами аргументов.

Функции не являются объектами. Поэтому не может быть массива функций, функция не может быть передана по значению или возвращена из другой функции. Хотя допускается использование ссылок и указателей на функции.

Методы - это особый вид функций, определяемых внутри класса. Методы могут быть статическими и не статическим. Статический метод отличается от обычной функции лишь тем, что определен внутри области видимости класса и имеет доступ к приватным полям объекта этого класса, переданного в качестве аргумента. Не статический метод имеет те же свойства, что и статический, но еще имеет неявный аргумент ```this``` - указатель на объект класса, для которого этот метод вызывается. Как и для обычных аргументов, для ```this``` можно определить cv-квалификатор, с которым это указатель будет передаваться. Этот квалификатор определяется после закрывающейся фигурной скобки со списком параметров. Также можно определить ref-квалификатор, который будет вызываться для объекта, являющегося ```lvalue``` или ```rvalue```: ```method_name() const &``` и ```method_name() &&``` соответственно.

## Перегрузка функций

Несколько функций в одной области видимости могут иметь одинаковое имя, если они имеют различное количество аргументов и/или аргументы имеют разные типы. Это называется перегрузкой функции. Не статические методы могут быть перегружены также с помощью cv/ref-квалификатора. Функции отличающиеся только типом возвращаемого значения перегрузкой не является, это приводит к ошибке компиляции.

Перегрузка функций не только делает код более читабельным (например, существует функция ```sin``` как для аргумента типа ```float```, так и для ```double```), но и позволяет вызывать их из шаблонных функций.

Еще одно замечательное применение перегрузки - это перегрузка операторов. Операторы - это специальные виды функций формата ```operator$```, которые, помимо обычного синтаксиса вызова, имеют альтернативный синтаксис в виде инфиксных, постфиксных или префиксных операций. Перегрузка операторов для пользовательских типов позволяет записывать математические и логические операции над этими типами в более удобочитаемом, естественном виде, аналогично операциям со встроенными типами.

### Разрешение перегрузки

Перегрузка функций упрощает жизнь программисту, но усложняет ее компилятору. Теперь, чтобы скомпилировать выражение с вызовом перегруженной функции требуется вычислить, какая именно функция должна быть вызвана.

Сначала осуществляется поиск функций-кандидатов по имени. Если кандидатов больше одного, что всегда истина для перегруженных функций, то применяется отбор функций на основе анализа аргументов.

Функция считается подходящей, если она:
* число параметров и аргументов точно совпадают;
* число параметров меньше числа аргументов, но она объявлена как функция с переменным числом аргументов;
* число параметров больше числа аргументов, но как минимум для всех недостающих параметров определены значения по умолчанию.

Также проверяется, что для всех аргументов существует последовательность неявного приведения к типу параметра. В цепочке неявных привидений может однократно применяться приведение, определенное пользователем. Для параметров ссылочного типа анализируется возможность привязки аргумента: ```rvalue``` ссылка не может быть привязана к неконстантной ```lvalue``` ссылке, а ```lvalue``` ссылка - к ```rvalue```.

Если на этом этапе осталось больше одной подходящей функции, то функции-кандидаты ранжируются по сложности приведения аргументов к типам параметров. Правила сравнения приведений довольно сложные, цепочки с пользовательскими приведениями всегда хуже цепочки, содержащей только стандартные приведения.

Если оценка сложности приведения аргументов не выявляет победителя, то осуществляется попытка оценить сложность приведения возвращаемого значения.

## Функторы

Функторами называются объекты в классе которого определен ```operator()```. Функторы не являются функциями и, как любые другие объекты, могут храниться в массивах, передаваться по значению и т. п. Однако наличие оператора круглые скобки позволяет использовать их как функции. Синтаксически вызов оператора функтора ничем не отличается от вызова функции. А тот факт, что они являются объектами, позволяет функторам иметь состояние. Это свойство часто используют при работе с контейнерами, например, с помощью функтора можно посчитать сумму всех элементов массива, передав его в стандартную функцию ```std::for_each```.

В остальном функторы ничем не отличаются от обычных функций. Оператор круглые скобки также можно перегружать, тогда функтор будет работать, как перегруженная функция. Правила разрешения перегрузки аналогичные.

## Лямбда-выражения

Лямбда-выражения пришли к нам из функционального программирования, и очень быстро получили распространения в других языках, включая С++. В C++ лямбда выражение создает замыкание, т. е. безымянный функтор, способный захватывать внешние переменные в контекст.

Технически лямбда-выражение является синтаксическим сахаром. Данное выражение автоматически преобразуется в класс, где захваченный контекст хранится в полях класса. Поля, соответствующие переменным, захваченным по ссылке, имеют ссылочный тип, а, захваченные по значению, имеют соответствующий константный тип. Если же требуется модифицировать данные, захваченные по значению, или вызывать их неконстантные методы, то лямбда должна быть определена с ключевым словом mutable. Это довольно необычно для C++. Будучи наследником C и обеспечивая обратную совместимость с ним, C++ считает переменную неконстантной, если явно не указано обратное. В случае же с лямбда-выражениями, чувствуется влияние более молодого языка Rust.
